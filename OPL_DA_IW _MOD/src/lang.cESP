#include "include/opl.h"
#include "include/lang.h"
#include "include/util.h"
#include "include/fntsys.h"
#include "include/ioman.h"
#include "include/themes.h"

// Language support
static char *internalSpanish[LANG_STR_COUNT] = {
    "Spanish (interno)",
    "Guardar cambios",
    "Atrás",
    "Conexión de red",
    "Opciones avanzadas",
    "<Sin configurar>",
    "Configuración guardada en %s",
    "¡Error al guardar la configuración!",
    "Salir",
    "Configuración principal",
    "Menú",
    "Juegos BDM",
    "Juegos Disco duro",
    "Juegos Red",
    "Aplicaciones",
    "Tema",
    "Idioma",
    "Se apagará el sistema.",
    "¿Salir al navegador de la consola?",
    "¿Cancelar actualización?",
    "%d: Disco duro no detectado.",
    "%d: Disco duro no formateado.",
    "%d: Error al iniciar red.",
    "%d: No se ha detectado adaptador de red.",
    "%d: No se puede conectar al servidor SMB.",
    "%d: No se puede iniciar sesión en el servidor SMB.",
    "%d: No se puede abrir la unidad compartida de SMB.",
    "%d: No se puede listar la unidad compartida de SMB.",
    "%d: No se pueden listar los juegos.",
    "%d: Servidor DHCP no disponible.",
    "%d: No hay conexión de red.",
    "Activado",
    "Desactivado",
    "OK",
    "Seleccionar",
    "Cancelar",
    "Círculo",
    "Equis",
    "Lista de juegos",
    "Configuración de Juego",
    "Borrar configuraciones",
    "Velocidad desplazamiento",
    "Lento",
    "Medio",
    "Rápido",
    "Menú predeterminado",
    "Cargar del disco",
    "Espera por favor.",
    "Error al cargar el código ID del juego.",
    "Automatic Sorting",
    "Error al cargar el archivo de idioma.",
    "Colores para depuración",
    "Mando no encontrado, esperando...",
    "Carátulas, serigrafías y fondos",
    "Pantalla panorámica",
    "Apagar PS2",
    "Cargando configuración...",
    "Guardando configuración...",
    "Iniciar dispositivo",
    "Actualizar",
    "Modo de inicio para BDM",
    "Modo de inicio para Disco duro",
    "Modo de inicio para Red",
    //START of OPL_DB tweaks
    "Modo de inicio para Aplicaciones",
    //END of OPL_DB tweaks
    "Automático",
    "Manual",
    "Iniciar servidor NBD",
    "Iniciando servidor NBD...",
    "Servidor NBD conectado...",
    "Error al iniciar el servidor NBD.",
    "Cerrando servidor NBD...",
    "Ruta del IGR",
    "Color de fondo",
    "Color de texto",
    "- Servidor SMB -",
    "Tipo de dirección IP",
    "Estática",
    "DHCP",
    "Dirección IP",
    "Dirección",
    "Máscara de subred",
    "Puerta de enlace predeterminada",
    "Servidor DNS",
    "Puerto",
    "Unidad o carpeta compartida",
    "Cuenta de usuario compartida",
    "Contraseña",
    "<Sin definir>",
    "Tipo de dirección",
    "IP",
    "NetBIOS",
    "Aceptar",
    "El archivo se borrará definitivamente, ¿continuar?",
    "Renombrar juego",
    "Borrar juego",
    "Iniciar",
    "Confifuracion de Pantalla",
    "Operaciones de escritura",
    "Recordar último juego en uso",
    "Botón de selección",
    "Error, el juego está fragmentado.",
    "Error, no se pudo iniciar el archivo.",
    "Testear cambios",
    "Dejar en blanco para autentificar como GUEST.",
    "Lectura precisa",
    "Modo sincronizado",
    "Desvincula el sistema",
    "Omite vídeos",
    "Emula DVD-DL",
    "Quita el IGR",
    "Cambiar el tamaño formateará la VMC.",
    "Crear",
    "Iniciar",
    "Modificar",
    "Abortar",
    "Reiniciar",
    "Usar genérica",
    "Configuración VMC",
    "Nombre",
    "Tamaño",
    "Estado",
    "Progreso",
    "Archivo VMC creado.",
    "Archivo VMC inválido, el tamaño es incorrecto.",
    "El archivo VMC debe ser creado.",
    "Error accediendo a la VMC %s, ¿continuar con la tarjeta de memoria en ranura %d)?",
    "Refresco automático de las listas",
    "Acerca del OPL",
    "Desarrolladores",
    "Testeadores",
    "Ruta predeterminada BDM",
    "Dejar en blanco para salida hacia el navegador de PS2.",
    "Valor en minutos, 0 para desactivar el paro automático.",
    "Paro automático rotación del disco duro",
    "Modo de vídeo",
    "Color de diálogos",
    "Color de selección",
    "Reinicio colores",
    "Info",
    "Archivo ELF personalizado",
    "Seleccionar color",
    "Reconexión",
    "Dejar en blanco para mostrar todas las unidades o carpetas compartidas.",
    "Ruta predeterminada conexión de red",
    "Retroceso",
    "Espacio",
    "Intro",
    "Modo",
    "Ranura VMC 1",
    "Ranura VMC 2",
    "ID del juego",
    "Modo DMA",
    "Sincronización vertical",
    "Modo 1",
    "Modo 2",
    "Modo 3",
    "Modo 4",
    "Modo 5",
    "Modo 6",
    "Configuración GSM",
    "Configuración de velocidad ethernet y duplex",
    "100Mbit Full-duplex",
    "100Mbit Half-duplex",
    "10Mbit Full-duplex",
    "10Mbit Half-duplex",
    "Opciones GSM",
    "Selector GSM",
    "Activa/Desactiva el GSM para forzar modos de vídeo.",
    "Modo de vídeo a forzar.",
    "Mueve la posición horizontal de la pantalla",
    "Horizontal adjustment.",
    "Posición vertical",
    "Mueve la posición vertical de la pantalla.",
    "Sobre escaneo",
    "Ajuste sobre escaneo.",
    "Omitir vídeos FMV",
    "Omite escenas Full Motion Vídeos.",
    "Configuración PS2RD (Cheat)",
    "Motor de trucos PS2RD",
    "Permitir que PS2RD parchee el juego.",
    "Modo PS2RD (Cheat)",
    "Auto-seleccionar o seleccionar códigos de juegos.",
    "Auto-seleccionar códigos",
    "Seleccionar códigos de juegos",
    "Error: fallo al cargar el archivo de códigos.",
    "No se han encontrado códigos.",
    "Descargar configuración predeterminada",
    "Descargar configuraciones de los juegos",
    "Sobrescribir configuración existente",
    "Actualización fallida.",
    "Error al conectarse con el servidor de actualización.",
    "Actualización completa.",
    "Actualización cancelada.",
    "¿Descargar configuración desde la red?",
    "Configuraciones personalizadas",
    "Descargada configuración predeterminada",
    "Inicio en %i s...",
    "Inicio automático",
    "Valor en segundos, 0 para desactivar el inicio automático.",
    "Logotipo Playstation 2",
    "Sólo se mostrará si el juego es de la misma región que la consola.",
    "Configuración DualShock 3/4 (PADEMU)",
    "Opciones emulación del mando",
    "Emulación del mando",
    "Activa/desactiva la emulación del mando para el juego seleccionado.",
    "Modo emulación del mando",
    "Selecciona el modo de emulación del mando.",
    "DualShock 3/4 USB",
    "DualShock 3/4 Bluetooth",
    "Ajustes para el puerto:",
    "Selecciona el puerto del mando emulado para aplicar los ajustes.",
    "Emulación",
    "Activa/Desactiva la emulación del mando para el puerto seleccionado.",
    "Vibración",
    "Activa/Desactiva la vibración para el mando emulado en el puerto seleccionado.",
    "Dirección MAC adaptador bluetooth USB::",
    "Mando sincronizado con dirección MAC:",
    "Sincronizar",
    "Sincronización mando DualShock",
    "Sincroniza el mando DualShock con la dirección MAC del adaptador bluetooth.",
    "No conectado",
    "Información adaptador bluetooth",
    "Muestra más información y las funciones soportadas.",
    "Versión HCI:",
    "Versión LMP:",
    "ID fabricante:",
    "Funciones soportadas:",
    "Sí",
    "No",
    "El adaptador bluetooth debe ser totalmente compatible con los mandos DS3/DS4.",
    "El adaptador bluetooth puede no funcionar correctamente con los mandos DS3/DS4.",
    "Emulación Multitap",
    "Activa/Desactiva la emulación Multitap para el juego seleccionado.",
    "Emulación Multitap en el puerto:",
    "Selecciona puerto para la emulación Multitap.",
    "Solución alternativa para los DS3 falsos",
    "Algunos DS3 falsos necesitan una solución alternativa, esta opción la activa.",
    "Emular alternancia de valores de CAMPO",
    "Solución para juegos que fallan bajo modos de vídeo progresivos.",
    "Configuración de control paterno",
    "Contraseña",
    "Dejar en blanco para desactivar el control paterno.",
    "Introduce contraseña de control paterno",
    "Contraseña control paterno incorrecta.",
    "Control paterno desactivado.",
    "Opciones de compilación:",
    "Error - esta contraseña no se puede usar.",
    "El archivo VMC %s está fragmentado. ¿Continuar con la tarjeta de memoria en ranura %d?",
    "Configuración de sonido",
    "Efectos de sonido",
    "Sonido de inicio",
    "Volumen efectos de sonido",
    "Volumen sonido de inicio",
    "¿Confirmar el cambio de modo de vídeo?",
    "Caché lista de juegos (Disco duro)",
    "Notificaciones",
    "Configuración cargada desde %s",
    "Tema cargado desde %s",
    "Idioma cargado desde %s",
    "Partición %s montada.",
    "Opciones",
    "Configuración del juego guardada.",
    "Ajuste %s borrado.",
    "Cuando se activa sobrescribe la configuración de compatibilidad del juego.",
    "Modo de configuración",
    "Global",
    "Por juego",
    "Todo",
    "Selecciona configuraciones para borrar.",
    "Foros de soporte:",
    "Título",
    "Género",
    "Lanzamiento",
    "Desarrollador",
    "Descripción",
    "Dispositivos de bloques",
    "Configuración del mando",
    "Activa/Desactiva el Gestor de Dispositivos de Bloque (Block Device Manager).",
    "elecciona dispositivos de bloque (Ejemplo: USB, iLink, MX4SIO).",
    "Juegos USB",
    "Juegos iLink",
    "Juegos MX4SIO",
    // START of OPL_DB tweaks
    "Juegos de PS1",
    "Modo de visualización de Juegos de PS1",
    "POPSTARTER.ELF no encontrado en '%s'!",
    "Archivo VCD no encontrado en '%s'!",
    "Se produjo un error al cambiar el nombre del archivo.",
    "Se produjo un error al eliminar el archivo.",
    "Gracias por elegirnos, somos PS2 Heavy Gamers y",
    "esta nuestra versión de (OPL) puede descargarla junto con",
    "nuestro paquete de FMCB en (GITHUB) https://bit.ly/3Dqa8d3",
    // END of OPL_DB tweaks
};

static int guiLangID = 0;
static char **lang_strs = internalSpanish;
static int nValidEntries = LANG_STR_COUNT;

static int nLanguages = 0;
static language_t languages[MAX_LANGUAGE_FILES];
static char **guiLangNames;

// localised string getter
char *_l(unsigned int id)
{
    return lang_strs[id];
}

static void lngFreeFromFile(char **lang_strs)
{
    if (guiLangID == 0)
        return;

    int strId = 0;
    for (; strId < nValidEntries; strId++) {
        free(lang_strs[strId]);
        lang_strs[strId] = NULL;
    }
    free(lang_strs);
    lang_strs = NULL;
}

static int lngLoadFont(const char *dir, const char *name)
{
    char path[256];

    snprintf(path, sizeof(path), "%sfont_%s.ttf", dir, name);
    LOG("LANG Custom TTF font path: %s\n", path);
    if (fntLoadDefault(path) == 0)
        return 0;

    snprintf(path, sizeof(path), "%sfont_%s.otf", dir, name);
    LOG("LANG Custom OTF font path: %s\n", path);
    if (fntLoadDefault(path) == 0)
        return 0;

    LOG("LANG cannot load font.\n");

    return -1;
}

static int lngLoadFromFile(char *path, char *name)
{
    char dir[128];

    file_buffer_t *fileBuffer = openFileBuffer(path, O_RDONLY, 1, 1024);
    if (fileBuffer) {
        // file exists, try to read it and load the custom lang
        char **curL = lang_strs;
        char **newL = (char **)calloc(LANG_STR_COUNT, sizeof(char *));

        int strId = 0;
        while (strId < LANG_STR_COUNT && readFileBuffer(fileBuffer, &newL[strId])) {
            strId++;
        }
        closeFileBuffer(fileBuffer);

        LOG("LANG Loaded %d entries\n", strId);

        int newEntries = strId;
        // if necessary complete lang with default internal
        while (strId < LANG_STR_COUNT) {
            LOG("LANG Default entry added: %s\n", internalSpanish[strId]);
            newL[strId] = internalSpanish[strId];
            strId++;
        }
        lang_strs = newL;
        lngFreeFromFile(curL);

        // remember how many entries were read from the file (for the free later)
        nValidEntries = newEntries;

        int len = strlen(path) - strlen(name) - 9; // -4 for extension,  -5 for prefix
        memcpy(dir, path, len);
        dir[len] = '\0';

        lngLoadFont(dir, name);

        return 1;
    }
    return 0;
}

char *lngGetValue(void)
{
    return guiLangNames[guiLangID];
}

static int lngReadEntry(int index, const char *path, const char *separator, const char *name, unsigned int mode)
{
    if (!S_ISDIR(mode)) {
        if (strstr(name, ".lng") || strstr(name, ".LNG")) {

            language_t *currLang = &languages[nLanguages + index];

            // filepath for this language file
            int length = strlen(path) + 1 + strlen(name) + 1;
            currLang->filePath = (char *)malloc(length * sizeof(char));
            sprintf(currLang->filePath, "%s%s%s", path, separator, name);

            // extract name for this language (will be used for the English translation)
            length = strlen(name) - 5 - 4 + 1;
            currLang->name = (char *)malloc(length * sizeof(char));
            memcpy(currLang->name, name + 5, length);
            currLang->name[length - 1] = '\0';

            /*file_buffer_t* fileBuffer = openFileBuffer(currLang->filePath, 1, 1024);
            if (fileBuffer) {
                // read localized name of language from file
                if (readLineContext(fileBuffer, &currLang->name))
                    readLineContext(fileBuffer, &currLang->fontName);
                closeFileBuffer(fileBuffer);
            }*/

            index++;
        }
    }
    return index;
}

static void lngRebuildLangNames(void)
{
    if (guiLangNames)
        free(guiLangNames);

    // build the languages name list
    guiLangNames = (char **)malloc((nLanguages + 2) * sizeof(char **));

    // add default internal (spanish)
    guiLangNames[0] = internalSpanish[0];

    int i = 0;
    for (; i < nLanguages; i++) {
        guiLangNames[i + 1] = languages[i].name;
    }

    guiLangNames[nLanguages + 1] = NULL;
}

int lngAddLanguages(char *path, const char *separator, int mode)
{
    int result;

    result = listDir(path, separator, MAX_LANGUAGE_FILES - nLanguages, &lngReadEntry);
    nLanguages += result;
    lngRebuildLangNames();

    const char *temp;
    if (configGetStr(configGetByType(CONFIG_OPL), "language_text", &temp)) {
        if (lngSetGuiValue(lngFindGuiID(temp)))
            moduleUpdateMenu(mode, 0, 1);
    }

    return result;
}

void lngInit(void)
{
    fntInit();

    lngAddLanguages(gBaseMCDir, "/", -1);
}

void lngEnd(void)
{
    lngFreeFromFile(lang_strs);

    int i = 0;
    for (; i < nLanguages; i++) {
        free(languages[i].name);
        free(languages[i].filePath);
    }

    free(guiLangNames);

    fntEnd();
}

int lngSetGuiValue(int langID)
{
    if (langID != -1) {
        if (guiLangID != langID) {
            if (langID != 0) {
                language_t *currLang = &languages[langID - 1];
                if (lngLoadFromFile(currLang->filePath, currLang->name)) {
                    guiLangID = langID;
                    thmSetGuiValue(thmGetGuiValue(), 1);
                    return 1;
                }
            }
            lang_strs = internalSpanish;
            guiLangID = 0;
            // lang switched back to internalSpanish, reload default font
            fntLoadDefault(NULL);
            thmSetGuiValue(thmGetGuiValue(), 1);
        }
    }
    return 0;
}

int lngGetGuiValue(void)
{
    return guiLangID;
}

int lngFindGuiID(const char *lang)
{
    if (lang) {
        int i = 0;
        for (; i < nLanguages; i++) {
            if (strcasecmp(languages[i].name, lang) == 0)
                return i + 1; // shift for Gui id
        }
    }
    return 0;
}

char **lngGetGuiList(void)
{
    return guiLangNames;
}

char *lngGetFilePath(int langID)
{
    language_t *currLang = &languages[langID - 1];
    char *path = currLang->filePath;

    return path;
}
